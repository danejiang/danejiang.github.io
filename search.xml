<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ServiceMix部署自定义开发程序(ActiveMQ和Kafka实现)]]></title>
    <url>%2F2019%2F04%2F24%2Fservicemix-example%2F</url>
    <content type="text"><![CDATA[上一篇整理了ServiceMix环境的搭建过程，接下来介绍在ServiceMix平台下如何开发程序并部署到Karaf容器内，同时介绍下karaf容器内置的ActiveMQ消息组件的发送和接收，以及目前应用比较广泛的分布式高吞吐量的消息系统Kafka在Karaf容器中的使用。 首先看下我们开发的程序部署的位置，我们使用Maven打包后的jar文件放在下图的deploy目录下，如果需要用到配置文件，可以放在etc目录下，该目录对应你Maven程序里的etc目录： 1.用IntelliJ创建maven项目，修改pom内容，定义项目名称和创建apache felix的plugin配置，并增加引用Kafka，完整内容请查阅后面的源码文件：12345678910111213141516171819&lt;groupId&gt;com.danejiang&lt;/groupId&gt;&lt;artifactId&gt;BundleTest&lt;/artifactId&gt;&lt;version&gt;1.0.0&lt;/version&gt;&lt;packaging&gt;bundle&lt;/packaging&gt;&lt;name&gt;DaneJiang BundleTest&lt;/name&gt;&lt;description&gt;DaneJiang BundleTest&lt;/description&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt; &lt;artifactId&gt;kafka-clients&lt;/artifactId&gt; &lt;version&gt;2.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.jmdns&lt;/groupId&gt; &lt;artifactId&gt;jmdns&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2.创建activemq.java，实现ActiveMQ的生产者发送消息、消费者接收消息处理和停止操作：ActiveMQ生产者发送消息代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public static boolean send(String topicType,String topicName, String topicMessage) &#123; try &#123; // 创建连接工厂 ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(&quot;tcp://0.0.0.0:61616&quot;); // 创建JMS连接实例，并启动连接 Connection connection = factory.createConnection(&quot;smx&quot;, &quot;smx&quot;); connection.start(); // 创建Session对象，不开启事务 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); // 创建主题和生成者：按消息类型分别处理 MessageProducer producer = null; if(topicType.toLowerCase().equals(&quot;queue&quot;))&#123; // 创建主题 Queue queue = session.createQueue(topicName); // 创建生成者 producer = session.createProducer(queue); &#125;else if(topicType.toLowerCase().equals(&quot;topic&quot;))&#123; // 创建主题 Topic topic = session.createTopic(topicName); // 创建生成者 producer = session.createProducer(topic); &#125;else&#123; logger.info(&quot;Send MQ Message error:not set topic type.&quot;); return false; &#125; // 设置消息不需持久化。默认消息需要持久化 //producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT); producer.setDeliveryMode(DeliveryMode.PERSISTENT); // 创建文本消息 或者其他格式的信息 TextMessage message = session.createTextMessage(topicMessage); // 发送消息。non-persistent 默认异步发送；persistent 默认同步发送 producer.send(message); // 关闭会话和连接 producer.close(); session.close(); connection.close(); logger.info(&quot;Send MQ Message:&quot; + topicName); return true; &#125; catch (Exception e) &#123; logger.info(&quot;Send MQ Message error:&quot; + e.toString()); return false; &#125;&#125; ActiveMQ消费者代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455private static Connection rConnection= null;private static Session rSession = null;private static MessageConsumer rMessageConsumer = null; public static boolean receive(String topicType, String topicName) &#123; try &#123; // 创建连接工厂 ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(&quot;tcp://0.0.0.0:61616&quot;); // 创建JMS连接实例，并启动连接 rConnection = connectionFactory.createConnection(&quot;smx&quot;, &quot;smx&quot;); rConnection.start(); // 创建Session对象，不开启事务 rSession = rConnection.createSession(false, Session.AUTO_ACKNOWLEDGE); // 创建主题和消费者：按消息类型分别处理 if (topicType.toLowerCase().equals(&quot;queue&quot;)) &#123; // 创建主题 Queue queue = rSession.createQueue(topicName); // 创建消费者 rMessageConsumer = rSession.createConsumer(queue); &#125; else if (topicType.toLowerCase().equals(&quot;topic&quot;)) &#123; // 创建主题 Topic topic = rSession.createTopic(topicName); // 创建消费者 rMessageConsumer = rSession.createConsumer(topic); &#125; else &#123; logger.info(&quot;Start MQ Message error:not set topic type.&quot;); return false; &#125; // 异步消费 rMessageConsumer.setMessageListener(new MessageListener() &#123; @Override public void onMessage(Message message) &#123; TextMessage mess = (TextMessage) message; try &#123; //消息处理 logger.info(&quot;Receive MQ Message:&quot; + topicName+&quot;,Result:&quot;+ mainService.doMQ(topicName, mess.getText())); &#125; catch (JMSException e) &#123; logger.info(&quot;Receive MQ Message error:&quot; + e.toString()); &#125; &#125; &#125;); logger.info(&quot;Started receive MQ Message:&quot; + topicName); return true; &#125; catch (Exception e) &#123; logger.info(&quot;Start receive MQ Message error:&quot; + e.toString()); return false; &#125;&#125; 下面的方法用于停止消费者的异步消费事件：123456789101112public static void stop() &#123; try &#123; // 关闭会话和连接 if (rMessageConsumer != null) rMessageConsumer.close(); if (rSession != null) rSession.close(); if (rConnection != null) rConnection.close(); logger.info(&quot;Stoped MQ Message.&quot;); &#125; catch (Exception e) &#123; logger.info(&quot;Stop MQ Message error:&quot; + e.toString()); &#125;&#125; 3.创建kafka.java，实现Kafka消息组件的生产者发送消息、消费者接收消息处理和停止操作：Kafka生产者代码如下：123456789101112131415161718192021222324252627282930313233public static boolean send(String topicName, String topicMessage) &#123; try &#123; Thread.currentThread().setContextClassLoader(null); Properties props = new Properties(); props.put(&quot;bootstrap.servers&quot;, &quot;hadoop01:9092&quot;); props.put(&quot;acks&quot;, &quot;all&quot;); props.put(&quot;retries&quot;, 0); props.put(&quot;batch.size&quot;, 16384); props.put(&quot;linger.ms&quot;, 1); props.put(&quot;buffer.memory&quot;, 33554432); props.put(&quot;key.serializer&quot;, &quot;org.apache.kafka.common.serialization.StringSerializer&quot;); props.put(&quot;value.serializer&quot;, &quot;org.apache.kafka.common.serialization.StringSerializer&quot;); Producer&lt;String, String&gt; producer = null; try &#123; producer = new KafkaProducer&lt;&gt;(props); producer.send(new ProducerRecord&lt;String, String&gt;(topicName, topicMessage)); &#125; catch (Exception e) &#123; logger.info(&quot;Send Kafka Message error:&quot; + e.toString()); return false; &#125; finally &#123; producer.close(); &#125; logger.info(&quot;Send Kafka Message:&quot; + topicName); return true; &#125; catch (Exception ex) &#123; logger.info(&quot;Send Kafka Message error:&quot; + ex.toString()); return false; &#125;&#125; Kafka消费者代码如下：1234567891011121314151617181920212223242526272829303132333435private static KafkaConsumer&lt;String, String&gt; kafkaConsumer = null;public static boolean receive() &#123; try &#123; Thread.currentThread().setContextClassLoader(null); Properties props = new Properties(); props.put(&quot;bootstrap.servers&quot;, &quot;hadoop01:9092&quot;); props.put(&quot;group.id&quot;, &quot;Group-1&quot;); props.put(&quot;enable.auto.commit&quot;, &quot;true&quot;); props.put(&quot;auto.commit.interval.ms&quot;, &quot;1000&quot;); props.put(&quot;auto.offset.reset&quot;, &quot;earliest&quot;); props.put(&quot;session.timeout.ms&quot;, &quot;30000&quot;); props.put(&quot;key.deserializer&quot;, &quot;org.apache.kafka.common.serialization.StringDeserializer&quot;); props.put(&quot;value.deserializer&quot;, &quot;org.apache.kafka.common.serialization.StringDeserializer&quot;); kafkaConsumer = new KafkaConsumer&lt;&gt;(props); kafkaConsumer.subscribe(Collections.singletonList(&quot;test&quot;)); SimpleDateFormat df = new SimpleDateFormat(&quot;yyyyMMddHHmmssSSS&quot;); new Thread(df.format(new Date())) &#123; public void run() &#123; while (true) &#123; ConsumerRecords&lt;String, String&gt; records = kafkaConsumer.poll(100); for (ConsumerRecord&lt;String, String&gt; record : records) &#123; logger.info(&quot;Receive Kafka Message:&quot; + record.topic()+&quot;,Result:&quot;+ mainService.doKafka(record.topic(),record.value())); &#125; &#125; &#125; &#125;.start(); return true; &#125; catch (Exception e) &#123; logger.info(&quot;Start receive Kafka Message error:&quot; + e.toString()); return false; &#125;&#125; 下面的方法用于停止消费者处理事件：12345678910public static void stop() &#123; try &#123; // 关闭会话和连接 if (kafkaConsumer != null) kafkaConsumer.close(); logger.info(&quot;Stop Kafka Message.&quot;); &#125; catch (Exception e) &#123; logger.info(&quot;Stop Kafka Message error:&quot; + e.toString()); &#125;&#125; 4.创建main函数，模拟消息组件的启动和停止事件，以及处理过程：start函数启动消费者监听事件，stop函数停止监听，后续这两个函数会和karaf中bundle的启动和停止事件绑定：12345678910111213141516171819202122232425public static void start() &#123; try &#123; //activemq消费者启动 activemq.receive(&quot;Topic&quot;, &quot;DaneJiang&quot;); //kafka消费者启动 kafka.receive(); logger.info(&quot;MainService start success.&quot;); &#125; catch (Exception ex) &#123; logger.info(&quot;MainService start error:&quot; + ex.toString()); &#125;&#125;public static void stop() &#123; try &#123; //activemq停止 activemq.stop(); //kafka停止 kafka.stop(); &#125; catch (Exception ex) &#123; logger.info(&quot;MainService stop error:&quot; + ex.toString()); &#125;&#125; 下面是接收到消息后的处理事件，具体内容根据需要自行调整：12345678910111213141516171819202122232425262728293031323334353637public static String doMQ(String topicName, String topicMessage) &#123; try &#123; String result = &quot;&quot;; switch (topicName.toUpperCase()) &#123; case &quot;DANEJIANG&quot;: result = topicMessage + &quot; World!&quot;; break; default: result = &quot;Receive Error Type:Type=&quot; + topicName + &quot;,Message=&quot; + topicMessage; break; &#125; return result; &#125; catch (Exception ex) &#123; logger.info(&quot;doMQ error:&quot; + ex.toString()); return ex.toString(); &#125;&#125;public static String doKafka(String topicName, String topicMessage) &#123; try &#123; String result = &quot;&quot;; switch (topicName.toUpperCase()) &#123; case &quot;DANEJIANG&quot;: result = topicMessage + &quot; World!&quot;; break; default: result = &quot;Receive Error Type:Type=&quot; + topicName + &quot;,Message=&quot; + topicMessage; break; &#125; return result; &#125; catch (Exception ex) &#123; logger.info(&quot;doKafka error:&quot; + ex.toString()); return ex.toString(); &#125;&#125; 5.最后创建文件Activator.java，用于处理bundle启动和停止时触发AceiveMQ和Kafka消息组件的对应事件：1234567891011121314151617import com.danejiang.service.mainService;import org.osgi.framework.BundleActivator;import org.osgi.framework.BundleContext;public class Activator implements BundleActivator &#123; @Override public void start(BundleContext arg0) throws Exception &#123; mainService.start(); System.out.println(&quot;start bundle!&quot;); &#125; @Override public void stop(BundleContext arg0) throws Exception &#123; mainService.stop(); System.out.println(&quot;stop bundle!&quot;); &#125;&#125; 6.代码完成后，用maven打包成jar文件，并将程序中lib目录下的jmdns-3.4.1.jar、kafka-clients-2.1.0.jar和lz4-java-1.5.0.jar一并上传至ServiceMix下的deploy目录中：使用命令bin/client进入karaf，输入bundle:list可以查看到相关组件已经启用：输入log:display可以查看组件的启动情况： 7.文章最后放上这次测试的源代码，水平有限还请各位指正错误，谢谢！https://github.com/danejiang/ServiceMix-Example]]></content>
      <categories>
        <category>ServiceMix</category>
      </categories>
      <tags>
        <tag>ServiceMix</tag>
        <tag>ActiveMQ</tag>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闲暇好风光]]></title>
    <url>%2F2019%2F04%2F20%2F20190420%2F</url>
    <content type="text"><![CDATA[难得出去逛一圈，看看风光，随手拍！]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ServiceMix环境搭建]]></title>
    <url>%2F2019%2F04%2F20%2Fservicemix-setup%2F</url>
    <content type="text"><![CDATA[由于项目需要，准备用ServiceMix搭建一个ESB服务，用于各系统之间数据接口的通讯；Apache ServiceMix是小巧的开源集成容器，它结合了Apache ActiveMQ、Camel、CXF和Karaf的特性和功能到一个强大的运行平台，你可以用它构建属于自己的集成解决方案。它提供了一个由OSGI技术支持的 全面的企业预备ESB。 下面简单介绍下ServiceMix环境搭建的几个步骤： 1.首先登陆官网下载安装包，并放到Linux服务器上：ServiceMix安装包页面 SSH登录服务器，进入安装包所在目录并解压文件：1tar -xvf apache-servicemix-7.0.1.tar 进入目录apache-servicemix-7.0.1，输入如下命令，启动ServiceMix：12cd apache-servicemix-7.0.1/bin/start 输入如下命令，进入karaf：1bin/client 2.输入如下命令，添加hawtio资源：1feature:repo-add hawtio 再输入如下命令，安装hawtio组件：1feature:install hawtio 安装完后通过访问http://服务器IP:8181，来查看ServiceMix的组件状态和日志： 3.输入如下命令安装wrapper，该组件提供开机自启动的相关命令：1wrapper:install 安装完成后，输入如下命令：1wrapper 执行完成后，出现如下提示，按系统设置开机启动：1234567891011121314151617* To install the service:* $ ln -s /opt/apache-servicemix-7.0.1/bin/karaf-service /etc/init.d/* * To start the service when the machine is rebooted:* $ update-rc.d karaf-service defaults* * To disable starting the service when the machine is rebooted:* $ update-rc.d -f karaf-service remove* * To start the service:* $ /etc/init.d/karaf-service start* * To stop the service:* $ /etc/init.d/karaf-service stop* * To uninstall the service :* $ rm /etc/init.d/karaf-service 4.安装需要使用的组件，目前我用jetty发布http服务，所以需要安装如下两个组件：12feature:install camel-httpfeature:install camel-jetty9]]></content>
      <categories>
        <category>ServiceMix</category>
      </categories>
      <tags>
        <tag>ServiceMix</tag>
        <tag>Karaf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F19%2Fhello-world%2F</url>
    <content type="text"><![CDATA[1Hello World! 我的开篇标题，觉得很适合我这种技术宅！ 十年，回想自己的第一个网站和博客，当时的心情很单纯，只想做一个编程技术资料和经验分享的网站；每天不停的访问着自己写的程序，到处推广自己的站点，不断的做SEO优化，看着被谷歌收录的页面逐渐变多，心情无比激动；但持续了一年左右，激情没了，加上网站的美工不行，网站一直没什么人访问，最后放弃了。 虽然有时还会搜索下自己以前的网页，但十年来一直没有下定决心再写一次博客；十年的时间，自己的编程技术略有增长，学习的领域已经有了翻天覆地的变化，目前正在学习大数据相关的技术，后续的文章中我会把学习的经验分享出来。 此次写博客，不追求形式、内容和时间，想写就写，只希望能记录一些自己在人生路上的点点滴滴，下一个十年来看时不会后悔！]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
        <tag>日记</tag>
      </tags>
  </entry>
</search>
